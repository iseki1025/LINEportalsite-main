<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F1ã‚«ãƒ¼éšœå®³ç‰©å›é¿</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* iPhone 1ç”»é¢ã«åã‚ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        body.theme-friend {
            padding: 0.5rem !important;
            min-height: auto !important;
        }

        .game-container {
            padding: 0.5rem !important;
            max-width: 100% !important;
        }

        .game-title {
            font-size: 1.2rem !important;
            margin: 0.3rem 0 !important;
        }

        .game-canvas-wrapper {
            position: relative;
            touch-action: none;
        }

        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å†…æç”»ãªã®ã§ä¸è¦ */
        .game-over-overlay {
            display: none !important;
        }

        /* æˆ»ã‚‹ãƒœã‚¿ãƒ³ï¼ˆanimal-mergeå½¢å¼ï¼‰ */
        .btn-back {
            display: inline-block;
            background: rgba(255, 255, 255, 0.9);
            color: #5a4a78;
            font-size: 0.8rem;
            padding: 0.5rem 1rem;
            border-radius: 1.5rem;
            text-decoration: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.2s;
            margin-top: 0.3rem;
        }

        .btn-back:hover {
            background: #fff;
            transform: scale(1.02);
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºï¼ˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã¨çµ±ä¸€ï¼‰ */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.4rem;
            margin: 0.5rem 0;
        }

        .stat-box {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 0.5rem 0.3rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.65rem;
            color: #666;
            margin-bottom: 0.15rem;
        }

        .stat-value {
            font-size: 0.95rem;
            font-weight: bold;
            color: #1a1a2e;
        }

        .stat-value.speed {
            color: #ef4444;
        }
    </style>
</head>

<body class="theme-friend">
    <div class="game-container">
        <h1 class="game-title">ğŸï¸ F1ã‚«ãƒ¼éšœå®³ç‰©å›é¿</h1>

        <div class="game-canvas-wrapper">
            <canvas id="gameCanvas" class="game-canvas" width="600" height="600"></canvas>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">æœ€é«˜è·é›¢</div>
                <div class="stat-value" id="score">0m</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">åˆ¤å®š</div>
                <div class="stat-value" id="estimatedAge">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰</div>
                <div class="stat-value speed" id="difficulty">Lv1</div>
            </div>
        </div>

        <a href="friend-game-main.html" class="btn-back">æˆ»ã‚‹</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const estimatedAgeDisplay = document.getElementById('estimatedAge');
        const difficultyDisplay = document.getElementById('difficulty');

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆiPhone 1ç”»é¢ã«åã¾ã‚‹ã‚ˆã†ã«ï¼‰
        function resizeCanvas() {
            const containerWidth = document.querySelector('.game-container').clientWidth;
            // ç”»é¢é«˜ã•ã‹ã‚‰ä»–ã®è¦ç´ åˆ†ã‚’å¼•ã„ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹æœ€å¤§ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            // ã‚¿ã‚¤ãƒˆãƒ«(ç´„35px) + ãƒ‘ãƒãƒ«(ç´„55px) + æˆ»ã‚‹ãƒœã‚¿ãƒ³(ç´„40px) + ãƒãƒ¼ã‚¸ãƒ³/ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°(ç´„50px) = ç´„180px
            const availableHeight = window.innerHeight - 180;
            const maxSize = Math.min(containerWidth - 16, availableHeight, 450);
            canvas.width = maxSize;
            canvas.height = maxSize;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let gameRunning = false;
        let isGameOver = false;
        let gameOverData = null; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        let startTime;
        let currentTime = 0;
        let level = 1;
        let currentSpeed;
        let roadOffset = 0;

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆF1ã‚«ãƒ¼ï¼‰
        const player = { x: 0, y: 0, width: 0, height: 0 };
        let obstacles = [];
        let obstacleSpawnRate = 1200;
        let lastObstacleSpawn = 0;
        let mouseX;

        // å›é¿æˆåŠŸã®ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼ˆå¹´é½¢åˆ¤å®šç”¨ï¼‰
        let dodgeData = [];
        let totalDodges = 0;
        let closeCalls = 0; // ã‚®ãƒªã‚®ãƒªå›é¿ã®å›æ•°

        // æœ€é«˜è¨˜éŒ²ï¼ˆãƒšãƒ¼ã‚¸å†…ã®ã¿ä¿æŒï¼‰
        let bestDistance = 0;
        let bestAge = '-';

        // éšœå®³ç‰©ã®ç¨®é¡
        const obstacleTypes = [
            { type: 'rock', color: '#6b7280', emoji: 'ğŸª¨' },
            { type: 'tire', color: '#1f2937', emoji: 'âš«' },
            { type: 'cone', color: '#f97316', emoji: 'ğŸ”¶' },
            { type: 'barrel', color: '#dc2626', emoji: 'ğŸ›¢ï¸' },
            { type: 'pothole', color: '#374151', emoji: 'ğŸ•³ï¸' },
            { type: 'box', color: '#78350f', emoji: 'ğŸ“¦' }
        ];

        // åå°„ç¥çµŒå¹´é½¢ã‚’è¨ˆç®—ï¼ˆå›é¿ã‚¹ã‚­ãƒ«ã‹ã‚‰ç®—å‡ºï¼‰
        function calculateReflexAge(time, speed, dodgeCount, closeCallCount) {
            // åŸºæœ¬ã‚¹ã‚³ã‚¢: ç”Ÿå­˜æ™‚é–“ã¨é›£æ˜“åº¦
            let baseScore = time * (1 + (level - 1) * 0.3);

            // ã‚¯ãƒ­ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ«ï¼ˆã‚®ãƒªã‚®ãƒªå›é¿ï¼‰ã®ãƒœãƒ¼ãƒŠã‚¹
            let closeCallBonus = closeCallCount * 2;

            // ç·åˆã‚¹ã‚³ã‚¢
            let totalScore = baseScore + closeCallBonus;

            // å¹´é½¢åˆ¤å®šãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆã‚¹ã‚³ã‚¢ãƒ™ãƒ¼ã‚¹ï¼‰
            if (totalScore >= 60) return { age: '10ä»£', detail: 'ãƒ—ãƒ­ãƒ¬ãƒ™ãƒ«ï¼ğŸ†' };
            if (totalScore >= 45) return { age: '20ä»£', detail: 'ç´ æ™´ã‚‰ã—ã„åå°„ç¥çµŒï¼' };
            if (totalScore >= 30) return { age: '30ä»£', detail: 'è‰¯å¥½ãªåå¿œé€Ÿåº¦ï¼' };
            if (totalScore >= 20) return { age: '40ä»£', detail: 'å¹³å‡çš„ãªåå°„ç¥çµŒ' };
            if (totalScore >= 12) return { age: '50ä»£', detail: 'ã¾ã ã¾ã ç¾å½¹ï¼' };
            if (totalScore >= 6) return { age: '60ä»£', detail: 'çµŒé¨“ã§ã‚«ãƒãƒ¼ï¼' };
            return { age: '70ä»£ä»¥ä¸Š', detail: 'ã®ã‚“ã³ã‚Šãƒ‰ãƒ©ã‚¤ãƒ–' };
        }

        // ç”»é¢å…¨ä½“ã§ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹æ“ä½œã‚’å—ã‘ä»˜ã‘
        const wrapper = document.querySelector('.game-canvas-wrapper');

        wrapper.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        });

        wrapper.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
        }, { passive: false });

        canvas.addEventListener('click', () => {
            if (!gameRunning && !isGameOver) {
                startGame();
            } else if (isGameOver) {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‹ã‚‰å†ã‚¹ã‚¿ãƒ¼ãƒˆ
                isGameOver = false;
                gameOverData = null;
                startGame();
            }
        });

        function startGame() {
            gameRunning = true;
            isGameOver = false;
            gameOverData = null;
            startTime = Date.now();
            currentTime = 0;
            level = 1;
            obstacles = [];
            currentSpeed = canvas.height / 150;
            obstacleSpawnRate = 1200;
            dodgeData = [];
            totalDodges = 0;
            closeCalls = 0;
            estimatedAgeDisplay.textContent = '-';
            roadOffset = 0;

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š
            player.width = canvas.width / 8;
            player.height = canvas.width / 5;
            player.x = canvas.width / 2;
            player.y = canvas.height - player.height - 20;
            mouseX = player.x;

            gameLoop();
        }

        function spawnObstacle() {
            const typeInfo = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const size = canvas.width / 12 + Math.random() * (canvas.width / 20);

            // é“è·¯ã®ç¸ã‚’é¿ã‘ã¦ã€é“è·¯å…¨å¹…ã§ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«å‡ºç¾
            const edgeWidth = canvas.width * 0.08;
            const minX = edgeWidth + size / 2;
            const maxX = canvas.width - edgeWidth - size / 2;
            const randomX = minX + Math.random() * (maxX - minX);

            obstacles.push({
                x: randomX,
                y: -size,
                width: size,
                height: size * 0.8,
                ...typeInfo,
                passed: false
            });
        }

        function drawRoad() {
            // é“è·¯èƒŒæ™¯
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // é“è·¯ã®ç¸ï¼ˆèŠç”Ÿï¼‰
            const edgeWidth = canvas.width * 0.08;
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(0, 0, edgeWidth, canvas.height);
            ctx.fillRect(canvas.width - edgeWidth, 0, edgeWidth, canvas.height);

            // è»Šç·šï¼ˆ3ãƒ¬ãƒ¼ãƒ³ï¼‰
            const laneWidth = (canvas.width - edgeWidth * 2) / 3;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 3;
            ctx.setLineDash([30, 30]);

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆã§å‹•ãè»Šç·š
            roadOffset = (roadOffset + currentSpeed * 2) % 60;

            for (let i = 1; i < 3; i++) {
                const x = edgeWidth + laneWidth * i;
                ctx.beginPath();
                ctx.moveTo(x, -60 + roadOffset);
                for (let y = -60 + roadOffset; y < canvas.height + 60; y += 60) {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + 30);
                }
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // å¤–å´ã®ç™½ç·š
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(edgeWidth, 0);
            ctx.lineTo(edgeWidth, canvas.height);
            ctx.moveTo(canvas.width - edgeWidth, 0);
            ctx.lineTo(canvas.width - edgeWidth, canvas.height);
            ctx.stroke();
        }

        function drawF1Car(x, y, width, height) {
            ctx.save();
            ctx.translate(x, y);

            const w = width;
            const h = height;

            // å¾Œè¼ª
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(-w * 0.55, h * 0.5, w * 0.15, h * 0.3);
            ctx.fillRect(w * 0.40, h * 0.5, w * 0.15, h * 0.3);

            // å‰è¼ª
            ctx.fillRect(-w * 0.45, -h * 0.3, w * 0.12, h * 0.25);
            ctx.fillRect(w * 0.33, -h * 0.3, w * 0.12, h * 0.25);

            // ãƒªã‚¢ã‚¦ã‚£ãƒ³ã‚°
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(-w * 0.4, h * 0.55, w * 0.8, h * 0.08);
            ctx.fillRect(-w * 0.05, h * 0.45, w * 0.1, h * 0.15);

            // ãƒœãƒ‡ã‚£æœ¬ä½“
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.5); // ãƒãƒ¼ã‚ºå…ˆç«¯
            ctx.lineTo(-w * 0.15, -h * 0.3);
            ctx.lineTo(-w * 0.3, h * 0.1);
            ctx.lineTo(-w * 0.35, h * 0.5);
            ctx.lineTo(w * 0.35, h * 0.5);
            ctx.lineTo(w * 0.3, h * 0.1);
            ctx.lineTo(w * 0.15, -h * 0.3);
            ctx.closePath();
            ctx.fill();

            // ã‚³ãƒƒã‚¯ãƒ”ãƒƒãƒˆ
            ctx.fillStyle = '#111827';
            ctx.beginPath();
            ctx.ellipse(0, h * 0.05, w * 0.12, h * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();

            // ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆ
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(0, -h * 0.05, w * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¦ã‚£ãƒ³ã‚°
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(-w * 0.35, -h * 0.4, w * 0.7, h * 0.06);

            // ãƒãƒ¼ã‚ºï¼ˆç™½ã„ã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼‰
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.5);
            ctx.lineTo(-w * 0.05, -h * 0.3);
            ctx.lineTo(w * 0.05, -h * 0.3);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawObstacle(obs) {
            ctx.save();
            ctx.translate(obs.x, obs.y);

            switch (obs.type) {
                case 'rock':
                    // å²©
                    ctx.fillStyle = '#6b7280';
                    ctx.beginPath();
                    ctx.moveTo(-obs.width / 2, obs.height / 3);
                    ctx.lineTo(-obs.width / 3, -obs.height / 3);
                    ctx.lineTo(obs.width / 4, -obs.height / 2);
                    ctx.lineTo(obs.width / 2, 0);
                    ctx.lineTo(obs.width / 3, obs.height / 2);
                    ctx.lineTo(-obs.width / 4, obs.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#4b5563';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;

                case 'tire':
                    // ã‚¿ã‚¤ãƒ¤
                    ctx.fillStyle = '#1f2937';
                    ctx.beginPath();
                    ctx.arc(0, 0, obs.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#374151';
                    ctx.beginPath();
                    ctx.arc(0, 0, obs.width / 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'cone':
                    // ã‚³ãƒ¼ãƒ³
                    ctx.fillStyle = '#f97316';
                    ctx.beginPath();
                    ctx.moveTo(0, -obs.height / 2);
                    ctx.lineTo(-obs.width / 2, obs.height / 2);
                    ctx.lineTo(obs.width / 2, obs.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-obs.width / 3, -obs.height / 6, obs.width * 2 / 3, obs.height / 6);
                    break;

                case 'barrel':
                    // ãƒ‰ãƒ©ãƒ ç¼¶
                    ctx.fillStyle = '#dc2626';
                    ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(-obs.width / 2, -obs.height / 4, obs.width, obs.height / 8);
                    ctx.fillRect(-obs.width / 2, obs.height / 8, obs.width, obs.height / 8);
                    break;

                case 'pothole':
                    // ç©´
                    ctx.fillStyle = '#111827';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, obs.width / 2, obs.height / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#4b5563';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    break;

                case 'box':
                    // ç®±
                    ctx.fillStyle = '#78350f';
                    ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                    ctx.strokeStyle = '#422006';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                    ctx.beginPath();
                    ctx.moveTo(-obs.width / 2, 0);
                    ctx.lineTo(obs.width / 2, 0);
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        function update() {
            currentTime = (Date.now() - startTime) / 1000;
            const distance = Math.floor(currentTime * currentSpeed * 2);
            scoreDisplay.textContent = distance + 'm';

            const newLevel = Math.floor(currentTime / 8) + 1;
            if (newLevel > level) {
                level = newLevel;
                currentSpeed += 0.8;
                obstacleSpawnRate = Math.max(400, 1200 - (level - 1) * 100);
                difficultyDisplay.textContent = 'Lv' + level;
            }

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•ï¼ˆã‚¹ãƒ ãƒ¼ã‚ºã«è¿½å¾“ï¼‰
            player.x += (mouseX - player.x) * 0.15;

            // ç”»é¢ç«¯ã®åˆ¶é™
            const minX = canvas.width * 0.08 + player.width / 2;
            const maxX = canvas.width - canvas.width * 0.08 - player.width / 2;
            if (player.x < minX) player.x = minX;
            if (player.x > maxX) player.x = maxX;

            // éšœå®³ç‰©ç”Ÿæˆ
            if (Date.now() - lastObstacleSpawn > obstacleSpawnRate) {
                spawnObstacle();
                lastObstacleSpawn = Date.now();
            }

            // éšœå®³ç‰©æ›´æ–°ã¨è¡çªåˆ¤å®š
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += currentSpeed;

                // ç°¡æ˜“çŸ©å½¢è¡çªåˆ¤å®š
                const playerLeft = player.x - player.width * 0.35;
                const playerRight = player.x + player.width * 0.35;
                const playerTop = player.y - player.height * 0.4;
                const playerBottom = player.y + player.height * 0.4;

                const obsLeft = obs.x - obs.width * 0.4;
                const obsRight = obs.x + obs.width * 0.4;
                const obsTop = obs.y - obs.height * 0.4;
                const obsBottom = obs.y + obs.height * 0.4;

                if (playerRight > obsLeft && playerLeft < obsRight &&
                    playerBottom > obsTop && playerTop < obsBottom) {
                    gameOver();
                    return;
                }

                // éšœå®³ç‰©ã‚’é€šéã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                if (!obs.passed && obs.y > player.y + player.height) {
                    obs.passed = true;
                    totalDodges++;

                    // ã‚®ãƒªã‚®ãƒªå›é¿åˆ¤å®š
                    const horizontalDist = Math.abs(obs.x - player.x);
                    if (horizontalDist < player.width) {
                        closeCalls++;
                    }
                }

                // ç”»é¢å¤–å‰Šé™¤
                if (obs.y - obs.height > canvas.height) {
                    obstacles.splice(i, 1);
                }
            }
        }

        function draw() {
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯å°‚ç”¨ç”»é¢ã‚’æç”»
            if (isGameOver) {
                drawGameOverScreen();
                return;
            }

            drawRoad();

            // éšœå®³ç‰©æç”»
            obstacles.forEach(obs => drawObstacle(obs));

            // F1ã‚«ãƒ¼æç”»
            drawF1Car(player.x, player.y, player.width, player.height);
        }

        function gameOver() {
            gameRunning = false;
            isGameOver = true;

            const reflexResult = calculateReflexAge(currentTime, currentSpeed, totalDodges, closeCalls);
            const distance = Math.floor(currentTime * currentSpeed * 2);

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            gameOverData = {
                distance: distance,
                level: level,
                dodges: totalDodges,
                closeCalls: closeCalls,
                reflexAge: reflexResult.age,
                reflexDetail: reflexResult.detail
            };

            // æœ€é«˜è¨˜éŒ²æ›´æ–°
            if (distance > bestDistance) {
                bestDistance = distance;
                scoreDisplay.textContent = bestDistance + 'm';
            }
            bestAge = reflexResult.age;
            estimatedAgeDisplay.textContent = bestAge;

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’æç”»
            drawGameOverScreen();
        }

        function drawGameOverScreen() {
            if (!gameOverData) return;

            // èƒŒæ™¯ã‚’ç›´æ¥æç”»ï¼ˆdraw()ã‚’å‘¼ã°ãšã«ï¼‰
            drawRoad();
            obstacles.forEach(obs => drawObstacle(obs));
            drawF1Car(player.x, player.y, player.width, player.height);

            // åŠé€æ˜ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.textAlign = 'center';

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#ff6b6b';
            ctx.font = `bold ${canvas.width / 10}px sans-serif`;
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height * 0.18);

            // ã‚¹ã‚³ã‚¢æƒ…å ±
            const lineHeight = canvas.height * 0.08;
            let y = canvas.height * 0.32;

            ctx.fillStyle = '#fff';
            ctx.font = `${canvas.width / 18}px sans-serif`;
            ctx.fillText(`èµ°è¡Œè·é›¢: ${gameOverData.distance}m`, canvas.width / 2, y);
            y += lineHeight;
            ctx.fillText(`ã‚¹ãƒ”ãƒ¼ãƒ‰: Lv${gameOverData.level}`, canvas.width / 2, y);
            y += lineHeight;
            ctx.fillText(`å›é¿æˆåŠŸ: ${gameOverData.dodges}å›`, canvas.width / 2, y);
            y += lineHeight;
            ctx.fillText(`ã‚®ãƒªã‚®ãƒªå›é¿: ${gameOverData.closeCalls}å›`, canvas.width / 2, y);

            // åå°„ç¥çµŒå¹´é½¢ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
            y += lineHeight * 1.3;
            ctx.fillStyle = '#fbbf24';
            ctx.font = `bold ${canvas.width / 12}px sans-serif`;
            ctx.fillText(`åå°„ç¥çµŒå¹´é½¢: ${gameOverData.reflexAge}`, canvas.width / 2, y);

            // è©³ç´°
            y += lineHeight * 0.7;
            ctx.fillStyle = '#9ca3af';
            ctx.font = `${canvas.width / 20}px sans-serif`;
            ctx.fillText(gameOverData.reflexDetail, canvas.width / 2, y);

            // ã‚¿ãƒƒãƒ—ã—ã¦å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            y = canvas.height * 0.9;
            ctx.fillStyle = '#fff';
            ctx.font = `${canvas.width / 16}px sans-serif`;
            ctx.fillText('ã‚¿ãƒƒãƒ—ã—ã¦å†ã‚¹ã‚¿ãƒ¼ãƒˆ', canvas.width / 2, y);
        }

        function gameLoop() {
            if (!gameRunning) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // åˆæœŸè¡¨ç¤º
        function drawStartScreen() {
            drawRoad();
            player.width = canvas.width / 8;
            player.height = canvas.width / 5;
            player.x = canvas.width / 2;
            player.y = canvas.height - player.height - 20;
            drawF1Car(player.x, player.y, player.width, player.height);

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = `bold ${canvas.width / 12}px sans-serif`;
            ctx.fillText('ğŸï¸ F1ã‚«ãƒ¼', canvas.width / 2, canvas.height / 2 - 30);
            ctx.font = `${canvas.width / 15}px sans-serif`;
            ctx.fillText('ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ', canvas.width / 2, canvas.height / 2 + 20);
        }

        drawStartScreen();
    </script>
</body>

</html>